!
! Copyright (C) 2001 PWSCF group
! This file is distributed under the terms of the
! GNU General Public License. See the file `License'
! in the root directory of the present distribution,
! or http://www.gnu.org/copyleft/gpl.txt .
!
!----------------------------------------------------------------------------
! TB
! setup of the gate, search for 'TB'
!----------------------------------------------------------------------------
!
!----------------------------------------------------------------------
SUBROUTINE setlocal
  !----------------------------------------------------------------------
  !! This routine computes the local potential in real space vltot(ir).
  !
  USE io_global,         ONLY : stdout
  USE kinds,             ONLY : DP
  USE constants,         ONLY : eps8, pi, AUTOEV
  USE ions_base,         ONLY : zv, ntyp => nsp, nat, tau
  USE cell_base,         ONLY : omega, at, bg
  USE extfield,          ONLY : tefield, dipfield, etotefield, gate, &
                                etotgatefield !TB
  USE gvect,             ONLY : igtongl, gg
  USE scf,               ONLY : rho, v_of_0, vltot
  USE vlocal,            ONLY : strf, vloc
  USE fft_base,          ONLY : dfftp
  USE fft_interfaces,    ONLY : invfft
  USE gvect,             ONLY : ngm
  USE control_flags,     ONLY : gamma_only
  USE mp_bands,          ONLY : intra_bgrp_comm
  USE mp,                ONLY : mp_sum
  USE martyna_tuckerman, ONLY : wg_corr_loc, do_comp_mt
  USE esm,               ONLY : esm_local, esm_bc, do_comp_esm
  USE qmmm,              ONLY : qmmm_add_esf
  USE Coul_cut_2D,       ONLY : do_cutoff_2D, cutoff_local 
  USE input_parameters,  ONLY : lmoire, vmoire_in_mev, pmoire_in_deg
  !
  IMPLICIT NONE
  !
  COMPLEX(DP), ALLOCATABLE :: aux(:), v_corr(:)
  ! auxiliary variable
  INTEGER :: nt, ng, ir, ni, nj, nk, jg, iat
  DOUBLE PRECISION :: rvec(3), gj(3), vm, phi, g6(3,6), vj
  ! counter on atom types
  ! counter on g vectors
  !
  ALLOCATE( aux(dfftp%nnr) )
  aux(:) = (0.d0,0.d0)
  !
  if (lmoire) then
  vltot(:) = 0.d0
  vm = vmoire_in_mev*1e-3/AUTOEV
  phi = pmoire_in_deg/180.d0*pi
  call hex_shell(g6)
  write(stdout, '("     Moire potential Vm = ",f12.2," meV on G shell:")') vmoire_in_mev
  do iat=1,6
    write(stdout, '("     ",3f11.6)') matmul(transpose(at), g6(:,iat))/(2.d0*pi)
  enddo
  nk = 0
  r_loop: do nj=0,dfftp%nr2-1
  do ni=0,dfftp%nr1-1
    ir = 1 + ni + dfftp%nr1x * ( nj + dfftp%nr2x*nk )
    rvec(1:3) = ni*at(1:3,1)/REAL(dfftp%nr1, DP) + &
                nj*at(1:3,2)/REAL(dfftp%nr2, DP) + &
                nk*at(1:3,3)/REAL(dfftp%nr3, DP)
    ! loop over hex_shell
    vj = 0.d0
    gj_loop: do jg=1,3
      gj = g6(:,2*jg)
      vj = vj+2*cos(phi+dot_product(gj,rvec))
    enddo gj_loop
    vltot(ir) = vm*vj/omega
    !write(42, '(3f16.8,f16.8)') rvec, vltot(ir)
  enddo
  enddo r_loop
  v_of_0 = sum(vltot)/dfftp%nnr
  write(stdout, '("     Moire V(G=0): ", f11.6, " ha")') v_of_0
  else ! not lmoire
  IF (do_comp_mt) THEN
     ALLOCATE( v_corr(ngm) )
     CALL wg_corr_loc( omega, ntyp, ngm, zv, strf, v_corr )
     aux(dfftp%nl(:)) = v_corr(:)
     DEALLOCATE( v_corr )
  ENDIF
  !
  DO nt = 1, ntyp
     DO ng = 1, ngm
        aux(dfftp%nl(ng)) = aux(dfftp%nl(ng)) + vloc(igtongl(ng),nt) &
                            * strf(ng,nt)
     ENDDO
  ENDDO
  !
  IF (gamma_only) THEN
     DO ng = 1, ngm
        aux(dfftp%nlm(ng)) = CONJG( aux(dfftp%nl(ng)) )
     ENDDO
  ENDIF
  !
  IF ( do_comp_esm .AND. ( esm_bc .NE. 'pbc' ) ) THEN
     !
     ! ... Perform ESM correction to local potential
     !
     CALL esm_local( aux )
     !
  ENDIF
  !
  ! 2D: re-add the erf/r function
  IF ( do_cutoff_2D ) THEN
     !
     ! ... re-add the CUTOFF fourier transform of erf function
     !
     CALL cutoff_local( aux )
     !
  ENDIF 
  !
  ! ... v_of_0 is (Vloc)(G=0)
  !
  v_of_0 = 0.0_DP
  IF (gg(1) < eps8) v_of_0 = DBLE( aux(dfftp%nl(1)) )
  !
  CALL mp_sum( v_of_0, intra_bgrp_comm )
  !
  ! ... aux = potential in G-space . FFT to real space
  !
  CALL invfft( 'Rho', aux, dfftp )
  !
  vltot(:) =  DBLE( aux(:) )
  endif ! lmoire
  !
  ! ... If required add an electric field to the local potential 
  !
  IF ( tefield .AND. ( .NOT. dipfield ) )  &
      CALL add_efield( vltot, etotefield, rho%of_r, .TRUE. )
  !
  ! TB
  ! if charged plate, call add_gatefield and add the linear potential,
  ! together with the background charge
  IF (gate) CALL add_gatefield( vltot, etotgatefield, .TRUE., .TRUE. )
  !
  !  ... Add the electrostatic field generated by MM atoms
  !  in a QM/MM calculation to the local potential
  !
  CALL qmmm_add_esf( vltot, dfftp )
  !
  ! ... Save vltot for possible modifications in plugins
  !
  CALL plugin_init_potential( vltot )
  !
  DEALLOCATE( aux )
  !
  !
  RETURN
  !
END SUBROUTINE setlocal

subroutine hex_shell(g6_out)
  USE constants,         ONLY : eps8, pi
  USE cell_base,         ONLY : bg, tpiba
  implicit none
  double precision, intent(out) :: g6_out(3,6)
  double precision :: g1(3), g6(3,6), angles(6)
  integer iangs(6), ih, ib1, ib2
  ! sort first shell of neighbors counter-clockwise from 9 o'clock (iangs)
  ih = 1
  do ib1 = -1,1
  do ib2 = -1,1
    g1 = ib1*bg(:, 1)*tpiba + ib2*bg(:, 2)*tpiba
    if (abs(g1(3)) > eps8) continue
    if (abs(norm2(g1)-4.d0*pi/sqrt(3.d0)) < eps8) then
      if (ih > 6) call errore('setlocal', 'more than 6 k points in first shell', 1)
      g6(1:3,ih) = g1(1:3)
      angles(ih) = atan2(g1(2), g1(1))
      ih = ih+1
    endif
  enddo
  if (abs(g1(3)) < eps8) continue
  enddo
  call hpsort(6, angles, iangs)
  do ih=1,6
    g6_out(:,ih) = g6(:,iangs(ih))
  enddo
end subroutine hex_shell
